---
title: "Arbeidskrav_4_DataScience"
format: html
editor: visual
---

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(readxl)
library(restatapi)
library(DescTools)
library(ggrepel)
library(flextable)
library(modelr)
library(plm)
library(broom)
library(sandwich)
```

Oppgaven handler om å hente regionale tall fra Eurostat direkte inn i R ved hjelp av et API.
Daten brukes til å analysere økonomiske forskjeller mellom regioner i Europa.
Arbeidskravet vil dermed ha:

-   Henter data på laveste regionale nivå (NUTS3)

-   Summerer (aggregerer) dataene oppover til NUTS2, NUTS1 og til slutt landnivå

-   Ser på BNP, befolkning og BNP per innbygger

-   Beregning av Gini-koeffisient for å måle ulikhet mellom regioner

    -   Innen hvert land (Mellom regioner)

    -   Samlet for EU + utvalgte søkerland

-   Dataene dekker perioden 2000 - 2023

-   Bruker tidyverse og list-columns for å organisere dataene ryddig, slik at hver rad kan inneholde egne datasett (nested tibbles).

## Toc. eurostat

Her velger vi å søke i tox_txt etter tabeller med BNP (GDP) på NUTS3-nivå ved hjelp av str_detect().

```{r}
# Her henter vi innholdsfortegnelsen fra Eurostat og legger det inn i en dataframe vi kaller "toc_txt"
toc_txt <- get_eurostat_toc(mode = "txt")

```

## GDP NUTS 3

Her henter vi inholdsfortegnelsen fra Eurostat.
Vi gjør dette ved å hente innholdsfortegnelsen i rent tekst format, der vi gir navnet toc_txt.
Siden vi ikke vet helt om det brukes store eller småe bokstaver her, så bruker vi regex for å matche begge deler.
Ved å bruke filter() velger vi tabeller som inneholder både "gdp" og "NUTS3", og med å bruke slect() ta vi kun med kollonene title og code.

Tabellen vises med flextable(), som gjør at resultatene kan lett leses.
For å sikre at begge ordene finnes i tittelen, bruker ci en AND-betingelse (&) mellom to str_detect() uttrykk.

```{r}
gdp_tabs <- toc_txt |>
# Regex AND external to regex
 filter(
 str_detect(
 string = title,
 # For å matche både små og store bokstaver
 pattern = '[Gg][Dd][Pp]'
 # AND vha. &
 ) &
 str_detect(
 string = title,
 # For å matche både små og store bokstaver og
 # space eller ikke før 3
 pattern = '[Nn][Uu][Tt][Ss]\\s*3'
 )
 ) |>
 select(title, code)
```

```{r}
gdp_tabs |>
 select(title, code) |>
 flextable() |>
 width(1, width = 3.5) |>
 width(2, width = 1.5)
```

Her bruker tabellen med koden nama_10r_3gdp, som inneholder BNP (GDP) på NUTS3-nivå.
For å se hvilken variabler og verder som finnes i datasettet, henter ci "Data Structure Definition" (DSD).
Denne informasjonen brukes til å sette riktige filters i spørringen mot Eurostat.
Det er spesielt viktig å bruke nuts_leve = "3" for å fikre at vi henter data på NUTS3-nivå, siden dette ikke er åpenbart dokumentert.

Vi Laster dermed ned «Data Structure Definition (DSD)» for tabellen med kode nama_10r_3gdp.

```{r}
# description nama_10r_3gdp
dsd_gdp <- get_eurostat_dsd("nama_10r_3gdp")
```

```{r}
dsd_gdp |>
 filter(concept %in% c('freq', 'unit')) |>
 flextable() |>
 width(j = 1, width = 1) |>
 width(j = 2, width = 2) |>
 width(j = 3, width = 2)
```

```{r}
dsd_gdp |>
 filter(concept %in% c('geo')) |>
 head(n = 10) |>
 flextable() |>
 width(j = 1, width = 1) |>
 width(j = 2, width = 2) |>
 width(j = 3, width = 2)
```

Utfra kodene i dsd_gdpkan vi da formulere følgende spørring mot Eurostat:

```{r}
#| eval: true
#| cache: true
# Gross domestic product (GDP) at current market prices by NUTS 3 regions
# id: nama_10r_3gdp
# Vi velger å hente samtlige soner for så å filtrere ut de få vi ikke trenger
gdp <- get_eurostat_data(
 id = "nama_10r_3gdp",
 filters = list(
 # neste linje viser hvordan vi kunne ha hentet ut data
 # for spesifiserte land
 # geo = c("AT", "DE", "DK", "FR"),
 nuts_level = "3",
 unit = "MIO_PPS_EU27_2020"
 ),
 exact_match = FALSE,
 date_filter = 2000:2023,
 stringsAsFactors = FALSE
 ) |>
 mutate(
 gdp_n3 = 1000000 * values
 ) |> 
  select(-c(unit, values)) |>
 # Vil bare ha NUTS 3 nivå (5 karakterer). Vil aggregere selv til NUTS2,
 # NUTS1 og NUTSc
 filter(str_length(geo) == 5) |> 
 as_tibble()
```

```{r}
dim(gdp)
```

```{r}
gdp
```

Her har vi konvertert gdp til euro fra milioner euro.
Vi vil og gi navnet gdp.
Vi velger og å benytte MI0_PPS_EU27_2020 som mål på BNP.

Vi har et lite problem for sonen IE053.
Her mangler vi gdp data for årene 2015, 2016 og 2017.
Dette vil gi oss problemer senere hvis vi ikke fikser det.

```{r}
gdp |>
 filter(geo == "IE053")

 print
```

Vi legger derfor disse til gdp som NA verdier.
Disse vil vi så erstatte med interpolerte verdier senere.

```{r}
ie_data <- tibble(
 geo = c("IE053", "IE053", "IE053"),
 time = c("2015", "2016", "2017"),
 gdp_n3 = c(NA, NA, NA)
)
```

```{r}
gdp <- rbind(gdp, ie_data)
```

```{r}
gdp <- gdp |>
 arrange(geo, time) |>
 mutate(
 gdp_n3 = zoo::na.approx(gdp_n3)
 )
```

```{r}
gdp |>
 filter(geo == "IE053") |>
 print(n = 25)
```

## Population demo_r_pjanaggr3

### Oppgave 1

1\.
Søk i toc_txt for tabeller med population og NUTS 3.
Pass på at dere dekker både population og Population og ulike skrivemåter for NUTS 3.
Vi vil bruke befolkningstabellen som har teksten: «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».

```{r}
pop_tab <- toc_txt |>
  filter(
    str_detect(title, regex("population", ignore_case = TRUE)) &
    str_detect(title, regex("NUTS\\s*3", ignore_case = TRUE))
  )
```

### Oppgave 2

i\.
Finn koden for tabellen med forklarende tekst «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».

```{r}
pop_tab |>
  filter(
    str_detect(title, regex("population", ignore_case = TRUE)) &
    str_detect(title, regex("NUTS\\s*3", ignore_case = TRUE))
  )

```

```{r}
pop_tab |>
  filter(
    str_detect(
      title,
      fixed("Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 region")
    )
  ) |>
  select(code)
```

ii. Last ned Data Structure Definition (DSD) for denne tabellen.

```{r}
# Så laster vi ned DSD for tabellen vi fant over.
dsd_pop <- get_eurostat_dsd("nama_10r_3popgdp")
```

iii. Bruk opplysningene i DSD for å formulere en spørring mot Eurostat og last ned dataene. Gi dataene lastet ned navnet pop. Vi er bare interessert i totalbefolkning og ignorerer derfor både kjønn og alder. Vi ønsker data for årene 2000-2023.

<!-- -->

iv. Bruk filter(str_length(geo) == 5) for å begrense datasettet til NUTS3 regioner.
    Vi vil gjøre vår egen aggregering.

v.  Hent data for samtlige land, dvs.
    vi trenger ikke sette noe filter for geo.
    Husk å konverter til tibble vha.
    as_tibble().

```{r}
#| eval: true
#| cache: true
pop <- get_eurostat_data(
 id = "nama_10r_3popgdp",
 filters = list(
 nuts_level = "3",
 unit = "THS"
 ),
 exact_match = FALSE,
 date_filter = 2000:2023,
 stringsAsFactors = FALSE
 ) |>
 mutate(
 pop_n3 = values * 1000
 ) |> 
  select(-c(unit, values)) |>
 filter(str_length(geo) == 5) |> 
 as_tibble()
```

```{r}
dim(pop)
```

### Oppgave 3

Gjør en left_join() av de to tabellene.
La gdp være venstre tabell (Viktig!).
Gi resultatet navnet gdp_pop.

```{r}
gdp_pop <- left_join(
  gdp,
  pop,
  by = c("geo", "time")
)
```

```{r}
dim(gdp_pop)
head(gdp_pop)
```

Gjør følgende tilpasning av gdp_pop og legger resultatet i variabelen eu_data.

```{r}
eu_data <- gdp_pop %>%
 # Trenger ikke ZZ sonene som er en slag oppsamlingssone
 # for ikke fordelte verdier
 filter(!str_sub(geo, 3, 4) == "ZZ") |>
 # Drop the EFTA countries Switzerland and Norway
 filter(!str_sub(geo, 1, 2) %in% c("CH", "NO")) |>
 # Drop the EU countries Netherlands and Portugal
 filter(!str_sub(geo, 1, 2) %in% c("NL", "PT")) |>
 # Drop candidate country Monte Negro because of data
 filter(!str_sub(geo, 1, 2) %in% c("ME")) |>
 # Drop a region of France in the Indian Ocean (Outre Mer); Mayotte
 # because of missing data
 filter(!geo == "FRY50") |>
 # note that a few countries will have missing data for
 # some years at the start of the period
 filter(time > 1999 & time < 2023)
```

Regn ut gdp per capita og kaller variabelen gdp_pc_n3.

```{r}
eu_data <- eu_data |>
  mutate(
    gdp_pc_n3 = gdp_n3 / pop_n3
  )
```

```{r}
dim(eu_data)
```

```{r}
c(
  sum(is.na(eu_data$gdp_n3)),
  sum(is.na(eu_data$pop_n3))
)
```

### Oppgave 4

Endre navnet på variabelen geo til n3 og lag variablene n2 (NUTS2), n1 (NUTS1) og nc (for «Country») fra variabelen n3.
Funksjonen str_sub() fra stringr pakken kan her være hendig å bruke.

```{r}
eu_data <- eu_data |>
  rename(
    n3 = geo
  ) |>
  mutate(
    n2 = str_sub(n3, 1, 4), #Adding column for NUTS2
    n1 = str_sub(n3, 1, 3), #NUTS1
    nc = str_sub(n3, 1, 2) # And finally country.s
  )
```

### Oppgave 5

Undersøk om vi har noen NUTS 3 soner med pop_n3 lik 0.
Hvis det er noen så endre disse til NA.

```{r}
# Sjekker om det finnes soner uten befolkning. Så synes ikke, og livet går videre. 
eu_data |>
  filter(pop_n3 == 0)
```

### Oppgave 6

Sjekker hvor mange NUTS3 soner vi har i hvert land.

```{r}
eu_data |>
  distinct(nc, n3)|>
  count(nc, name ="antall_nuts3")|>
  as_flextable()
```

### Oppgave 7

Sjekk summary gdp_pc_n3.
Hva er største og minste verdi?
Har vi noen NA?

```{r}
  summary(eu_data$gdp_pc_n3)
```

Minsteverdi er 2 214, mens høyeste er 180 416.
Ingen NA.

### Oppgave 8

Bruker case_when() for å legge til variabelen nc_name før vi går videre.
Østerrike for AT, Belgia for BE etc..

```{r}
eu_data <- eu_data |>
  mutate(
    nc_name = case_when(
      nc == "AL" ~ "Albania",
      nc == "AT" ~ "Østerrike",
      nc == "BE" ~ "Belgia",
      nc == "BG" ~ "Bulgaria",
      nc == "CY" ~ "Kypros",
      nc == "CZ" ~ "Tjekkia",
      nc == "DE" ~ "Tyskland",
      nc == "DK" ~ "Danmark",
      nc == "EE" ~ "Estland",
      nc == "EL" ~ "Hellas",
      nc == "ES" ~ "Spania",
      nc == "FI" ~ "Finland",
      nc == "FR" ~ "Frankrike",
      nc == "HR" ~ "Kroatia",
      nc == "HU" ~ "Ungarn",
      nc == "IE" ~ "Irland",
      nc == "IT" ~ "Italia",
      nc == "LT" ~ "Litauen",
      nc == "LU" ~ "Luxemburg",
      nc == "LV" ~ "Latvia",
      nc == "MK" ~ "Nord-Makedonia",
      nc == "MT" ~ "Malta",
      nc == "PL" ~ "Polen",
      nc == "RO" ~ "Romania",
      nc == "RS" ~ "Serbia",
      nc == "SE" ~ "Sverige",
      nc == "SI" ~ "Slovania",
      nc == "SK" ~ "Slovakia",
      nc == "TR" ~ "Tyrkia",
      TRUE ~ NA_character_
    )
  )
```
