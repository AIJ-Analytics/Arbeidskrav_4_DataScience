---
title: "Arbeidskrav_4_DataScience"
format: html
editor: visual
---

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(readxl)
library(restatapi)
library(DescTools)
library(ggrepel)
library(flextable)
library(modelr)
library(plm)
library(broom)
library(sandwich)
```

```{r}
Sys.setlocale("LC_ALL", "Norwegian")
```

Oppgaven handler om å hente regionale tall fra Eurostat direkte inn i R ved hjelp av et API.
Daten brukes til å analysere økonomiske forskjeller mellom regioner i Europa.
Arbeidskravet vil dermed ha:

-   Henter data på laveste regionale nivå (NUTS3)

-   Summerer (aggregerer) dataene oppover til NUTS2, NUTS1 og til slutt landnivå

-   Ser på BNP, befolkning og BNP per innbygger

-   Beregning av Gini-koeffisient for å måle ulikhet mellom regioner

    -   Innen hvert land (Mellom regioner)

    -   Samlet for EU + utvalgte søkerland

-   Dataene dekker perioden 2000 - 2023

-   Bruker tidyverse og list-columns for å organisere dataene ryddig, slik at hver rad kan inneholde egne datasett (nested tibbles).

## Toc. eurostat

Her velger vi å søke i tox_txt etter tabeller med BNP (GDP) på NUTS3-nivå ved hjelp av str_detect().

```{r}
# Her henter vi innholdsfortegnelsen fra Eurostat og legger det inn i en dataframe vi kaller "toc_txt"
toc_txt <- get_eurostat_toc(mode = "txt")

```

## GDP NUTS 3

Her henter vi inholdsfortegnelsen fra Eurostat.
Vi gjør dette ved å hente innholdsfortegnelsen i rent tekst format, der vi gir navnet toc_txt.
Siden vi ikke vet helt om det brukes store eller småe bokstaver her, så bruker vi regex for å matche begge deler.
Ved å bruke filter() velger vi tabeller som inneholder både "gdp" og "NUTS3", og med å bruke slect() ta vi kun med kollonene title og code.

Tabellen vises med flextable(), som gjør at resultatene kan lett leses.
For å sikre at begge ordene finnes i tittelen, bruker ci en AND-betingelse (&) mellom to str_detect() uttrykk.

```{r}
gdp_tabs <- toc_txt |>
# Regex AND external to regex
 filter(
 str_detect(
 string = title,
 # For å matche både små og store bokstaver
 pattern = '[Gg][Dd][Pp]'
 # AND vha. &
 ) &
 str_detect(
 string = title,
 # For å matche både små og store bokstaver og
 # space eller ikke før 3
 pattern = '[Nn][Uu][Tt][Ss]\\s*3'
 )
 ) |>
 select(title, code)
```

```{r}
gdp_tabs |>
 select(title, code) |>
 flextable() |>
 width(1, width = 3.5) |>
 width(2, width = 1.5)
```

Her bruker tabellen med koden nama_10r_3gdp, som inneholder BNP (GDP) på NUTS3-nivå.
For å se hvilken variabler og verder som finnes i datasettet, henter ci "Data Structure Definition" (DSD).
Denne informasjonen brukes til å sette riktige filters i spørringen mot Eurostat.
Det er spesielt viktig å bruke nuts_leve = "3" for å fikre at vi henter data på NUTS3-nivå, siden dette ikke er åpenbart dokumentert.

Vi Laster dermed ned «Data Structure Definition (DSD)» for tabellen med kode nama_10r_3gdp.

```{r}
# description nama_10r_3gdp
dsd_gdp <- get_eurostat_dsd("nama_10r_3gdp")
```

```{r}
dsd_gdp |>
 filter(concept %in% c('freq', 'unit')) |>
 flextable() |>
 width(j = 1, width = 1) |>
 width(j = 2, width = 2) |>
 width(j = 3, width = 2)
```

```{r}
dsd_gdp |>
 filter(concept %in% c('geo')) |>
 head(n = 10) |>
 flextable() |>
 width(j = 1, width = 1) |>
 width(j = 2, width = 2) |>
 width(j = 3, width = 2)
```

Utfra kodene i dsd_gdpkan vi da formulere følgende spørring mot Eurostat:

```{r}
#| eval: true
#| cache: true
# Gross domestic product (GDP) at current market prices by NUTS 3 regions
# id: nama_10r_3gdp
# Vi velger å hente samtlige soner for så å filtrere ut de få vi ikke trenger
gdp <- get_eurostat_data(
 id = "nama_10r_3gdp",
 filters = list(
 # neste linje viser hvordan vi kunne ha hentet ut data
 # for spesifiserte land
 # geo = c("AT", "DE", "DK", "FR"),
 nuts_level = "3",
 unit = "MIO_PPS_EU27_2020"
 ),
 exact_match = FALSE,
 date_filter = 2000:2023,
 stringsAsFactors = FALSE
 ) |>
 mutate(
 gdp_n3 = 1000000 * values
 ) |> 
  select(-c(unit, values)) |>
 # Vil bare ha NUTS 3 nivå (5 karakterer). Vil aggregere selv til NUTS2,
 # NUTS1 og NUTSc
 filter(str_length(geo) == 5) |> 
 as_tibble()
```

```{r}
dim(gdp)
```

```{r}
gdp
```

Her har vi konvertert gdp til euro fra milioner euro.
Vi vil og gi navnet gdp.
Vi velger og å benytte MI0_PPS_EU27_2020 som mål på BNP.

Vi har et lite problem for sonen IE053.
Her mangler vi gdp data for årene 2015, 2016 og 2017.
Dette vil gi oss problemer senere hvis vi ikke fikser det.

```{r}
gdp |>
 filter(geo == "IE053")

 print
```

Vi legger derfor disse til gdp som NA verdier.
Disse vil vi så erstatte med interpolerte verdier senere.

```{r}
ie_data <- tibble(
 geo = c("IE053", "IE053", "IE053"),
 time = c("2015", "2016", "2017"),
 gdp_n3 = c(NA, NA, NA)
)
```

```{r}
gdp <- rbind(gdp, ie_data)
```

```{r}
gdp <- gdp |>
 arrange(geo, time) |>
 mutate(
 gdp_n3 = zoo::na.approx(gdp_n3)
 )
```

```{r}
gdp |>
 filter(geo == "IE053") |>
 print(n = 25)
```

## Population demo_r_pjanaggr3

### Oppgave 1

1\.
Søk i toc_txt for tabeller med population og NUTS 3.
Pass på at dere dekker både population og Population og ulike skrivemåter for NUTS 3.
Vi vil bruke befolkningstabellen som har teksten: «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».

```{r}
pop_tab <- toc_txt |>
  filter(
    str_detect(title, regex("population", ignore_case = TRUE)) &
    str_detect(title, regex("NUTS\\s*3", ignore_case = TRUE))
  )
```

### Oppgave 2

i\.
Finn koden for tabellen med forklarende tekst «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».

```{r}
pop_tab |>
  filter(
    str_detect(title, regex("population", ignore_case = TRUE)) &
    str_detect(title, regex("NUTS\\s*3", ignore_case = TRUE))
  )

```

```{r}
pop_tab |>
  filter(
    str_detect(
      title,
      fixed("Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 region")
    )
  ) |>
  select(code)
```

ii. Last ned Data Structure Definition (DSD) for denne tabellen.

```{r}
# Så laster vi ned DSD for tabellen vi fant over.
dsd_pop <- get_eurostat_dsd("nama_10r_3popgdp")
```

iii. Bruk opplysningene i DSD for å formulere en spørring mot Eurostat og last ned dataene. Gi dataene lastet ned navnet pop. Vi er bare interessert i totalbefolkning og ignorerer derfor både kjønn og alder. Vi ønsker data for årene 2000-2023.

<!-- -->

iv. Bruk filter(str_length(geo) == 5) for å begrense datasettet til NUTS3 regioner.
    Vi vil gjøre vår egen aggregering.

v.  Hent data for samtlige land, dvs.
    vi trenger ikke sette noe filter for geo.
    Husk å konverter til tibble vha.
    as_tibble().

```{r}
#| eval: true
#| cache: true
pop <- get_eurostat_data(
 id = "nama_10r_3popgdp",
 filters = list(
 nuts_level = "3",
 unit = "THS"
 ),
 exact_match = FALSE,
 date_filter = 2000:2023,
 stringsAsFactors = FALSE
 ) |>
 mutate(
 pop_n3 = values * 1000
 ) |> 
  select(-c(unit, values)) |>
 filter(str_length(geo) == 5) |> 
 as_tibble()
```

```{r}
dim(pop)
```

### Oppgave 3

Gjør en left_join() av de to tabellene.
La gdp være venstre tabell (Viktig!).
Gi resultatet navnet gdp_pop.

```{r}
gdp_pop <- left_join(
  gdp,
  pop,
  by = c("geo", "time")
)
```

```{r}
dim(gdp_pop)
head(gdp_pop)
```

Gjør følgende tilpasning av gdp_pop og legger resultatet i variabelen eu_data.

```{r}
eu_data <- gdp_pop %>%
 # Trenger ikke ZZ sonene som er en slag oppsamlingssone
 # for ikke fordelte verdier
 filter(!str_sub(geo, 3, 4) == "ZZ") |>
 # Drop the EFTA countries Switzerland and Norway
 filter(!str_sub(geo, 1, 2) %in% c("CH", "NO")) |>
 # Drop the EU countries Netherlands and Portugal
 filter(!str_sub(geo, 1, 2) %in% c("NL", "PT")) |>
 # Drop candidate country Monte Negro because of data
 filter(!str_sub(geo, 1, 2) %in% c("ME")) |>
 # Drop a region of France in the Indian Ocean (Outre Mer); Mayotte
 # because of missing data
 filter(!geo == "FRY50") |>
 # note that a few countries will have missing data for
 # some years at the start of the period
 filter(time > 1999 & time < 2023)
```

Regn ut gdp per capita og kaller variabelen gdp_pc_n3.

```{r}
eu_data <- eu_data |>
  mutate(
    gdp_pc_n3 = gdp_n3 / pop_n3
  )
```

```{r}
dim(eu_data)
```

```{r}
miss_eu <- eu_data %>% 
  filter(!complete.cases(.))
dim(miss_eu)
```

```{r}
# don't run if you don't mean it.
rm(list = setdiff(ls(), c("eu_data")))
```

### Oppgave 4

Endre navnet på variabelen geo til n3 og lag variablene n2 (NUTS2), n1 (NUTS1) og nc (for «Country») fra variabelen n3.
Funksjonen str_sub() fra stringr pakken kan her være hendig å bruke.

```{r}
eu_data <- eu_data |>
  rename(
    n3 = geo
  ) |>
  mutate(
    n2 = str_sub(n3, 1, 4), #Adding column for NUTS2
    n1 = str_sub(n3, 1, 3), #NUTS1
    nc = str_sub(n3, 1, 2) # And finally country.s
  )
```

### Oppgave 5

Undersøk om vi har noen NUTS 3 soner med pop_n3 lik 0.
Hvis det er noen så endre disse til NA.

```{r}
# Sjekker om det finnes soner uten befolkning. Så synes ikke, og livet går videre. 
eu_data |>
  filter(pop_n3 == 0)
```

### Oppgave 6

Sjekker hvor mange NUTS3 soner vi har i hvert land.

```{r}
eu_data |>
  distinct(nc, n3)|>
  count(nc, name ="antall_nuts3")|>
  as_flextable()
```

### Oppgave 7

Sjekk summary gdp_pc_n3.
Hva er største og minste verdi?
Har vi noen NA?

```{r}
  summary(eu_data$gdp_pc_n3)
```

Minsteverdi er 2 214, mens høyeste er 180 416.
Ingen NA.

### Oppgave 8

Bruker case_when() for å legge til variabelen nc_name før vi går videre.
Østerrike for AT, Belgia for BE etc..

```{r}
eu_data <- eu_data |>
  mutate(
    nc_name = case_when(
      nc == "AL" ~ "Albania",
      nc == "AT" ~ "Østerrike",
      nc == "BE" ~ "Belgia",
      nc == "BG" ~ "Bulgaria",
      nc == "CY" ~ "Kypros",
      nc == "CZ" ~ "Tjekkia",
      nc == "DE" ~ "Tyskland",
      nc == "DK" ~ "Danmark",
      nc == "EE" ~ "Estland",
      nc == "EL" ~ "Hellas",
      nc == "ES" ~ "Spania",
      nc == "FI" ~ "Finland",
      nc == "FR" ~ "Frankrike",
      nc == "HR" ~ "Kroatia",
      nc == "HU" ~ "Ungarn",
      nc == "IE" ~ "Irland",
      nc == "IT" ~ "Italia",
      nc == "LT" ~ "Litauen",
      nc == "LU" ~ "Luxemburg",
      nc == "LV" ~ "Latvia",
      nc == "MK" ~ "Nord-Makedonia",
      nc == "MT" ~ "Malta",
      nc == "PL" ~ "Polen",
      nc == "RO" ~ "Romania",
      nc == "RS" ~ "Serbia",
      nc == "SE" ~ "Sverige",
      nc == "SI" ~ "Slovania",
      nc == "SK" ~ "Slovakia",
      nc == "TR" ~ "Tyrkia",
      TRUE ~ NA_character_
    )
  )
```

## Beregning av Gini

### Oppgave 9

Bruk koden nedenfor til å beregne Gini-koeffisienter på NUTS2 nivå.
Finn også antall NUTS3 regioner som finnes i hver NUTS2 region.
Gi denne variabelen navnet num_reg_n2.
Vi beregner også populasjon og gdp på NUTS2 nivå.
Resultatet legger dere i en tibble kalt gini_n2.

```{r}
gini_n2 <- eu_data |>
 group_by(n2, time, n1, nc, nc_name) |>
 summarise(
 gini_n2 = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
 pop_n2 = sum(pop_n3),
 gdp_n2 = sum(gdp_n3),
 gdp_pc_n2 = gdp_n2 / pop_n2,
 num_reg_n2 = n(),
 .groups = "drop"
 )|>
  as_tibble()
```

```{r}
head(gini_n2, 10)
```

```{r}
summary(gini_n2)
```

### Oppgave 10

Sjekk obs.
med Gini mindre enn 0.001.
Er det noe som kjennetegner disse regionene?

For å løse denne gikk vi inn i R-objektet og filtrerte etter utregnet Gini.
Når vi filtrerte etter Gini mellom 0 og 0,001 fikk vi 4 observasjoner:

```{r}
gini_n2 %>%
  filter(gini_n2 < 0.001)
```

De er spredt geografisk, i tid og har forskjellig GDP.
Det de derimot har til felles, er at alle inneholder 2 NUTS3-regioner.
At de har få regioner å regne ulikhet fra påvirker resultatet.

### Oppgave 11

Beregn Gini-koeffisienter på NUTS1 nivå (ut fra gdp_pc_n3og pop_n3).
Legg resultatet i gini_n1.
Et alternativ her ville vært å beregnet Gini fra gdp_pc_n2 og pop_n2 i NUTS1 regionene.
Vi får imidlertid større spredning og trolig også et bedre mål på likhet/ulikhet ved å beregne Gini utfra gdp_pc_n3og pop_n3.

```{r}
#Trur denne er rett?
gini_n1 <- eu_data |>
  group_by(n1, time, nc, nc_name) |>
  summarise(
    gini_n1 = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
    pop_n1 = sum(pop_n3, na.rm = TRUE),
    gdp_n1 = sum(gdp_n3, na.rm = TRUE),
    gdp_pc_n1 = gdp_n1 / pop_n1,
    num_reg_n1 = n_distinct(n3),
    .groups = "drop"
  ) |>
  as_tibble()
```

Vår summary:

```{r}

gini_n1 |>
 select(gini_n1, num_reg_n1, gdp_n1, pop_n1, gdp_pc_n1) |>
 summary() |>
 print(width = 76)
```

Ser lik ut som "fasit".
Great success!
High five.

### Oppgave 12

Beregn Gini-koeffisienter (ut fra variasjon i verdiskapning på NUTS3 nivå) på nasjonsnivå.
Legg resultatet i gini_nc.

```{r}
gini_nc <- eu_data |>
  group_by(nc, nc_name, time) |>
  summarise(
    gini_nc = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
    pop_nc = sum(pop_n3, na.rm = TRUE),
    gdp_nc = sum(gdp_n3, na.rm = TRUE),
    gdp_pc_nc = gdp_nc / pop_nc,
    num_reg_nc = n_distinct(n3),
    .groups = "drop"
  ) |>
  as_tibble()
```

```{r}
summary(gini_nc)
```

Denne ser også ut som løsningsforslaget.

## Nestete Datastrukturer

### Oppgave 13

```{r}
gini_n3_nest <- eu_data |>
 group_by(nc_name, nc) |>
 nest(.key = "NUTS3_data") |>
 ungroup()

```

### Oppgave 14

Nest dataene på NUTS2 nivå.
Legg resultatet gini_NUTS2_nest.
Bruk .key = "NUTS2_data".

```{r}
gini_n2_nest <- gini_n2 |>
  group_by(nc_name, nc)|>
 nest(.key = "NUTS2_data")
```

### Oppgave 15

«Nest» dataene på NUTS1 nivå.
Legg resultatet gini_NUTS1_nest.

```{r}
gini_n1_nest <- gini_n1 |>
 group_by(nc_name, nc) |>
 nest(.key = "NUTS1_data") |>
 ungroup()
```

### Oppgave 16

«Nest» dataene på nasjonsnivå.
Legg resultatet i gini_NUTSc_nest.

```{r}
gini_NUTSc_nest <- gini_nc |>
 group_by(nc_name, nc) |>
 nest(.key = "NUTSc_data") |>
 ungroup()
```

### Oppgave 17

```{r}
gini_NUTSeu_nest <- eu_data |>
 group_by(time) |>
 summarise(
 gini_eu = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
 num_reg_eu = n(),
 .groups = "drop")
```

### Oppgave 18

Vis utviklingen i Gini-koeffisienten for NUTS3 regioner i EU vha.
et linjeplot.

```{r}
gini_NUTSeu_nest |>
  ggplot(aes(x = as.numeric(time), y = gini_eu)) +
  geom_line() +
  labs(
    x = "Year",
    y = "gini_eu"
  )
```

### Oppgave 19

«The EU’s Structural Funds and Cohesion Fund direct funding to NUTS level 2 regions based on their GDP (PPS) per capita in comparison to the EU average: less developed regions (less than 75%), transition regions (between 75% and 90% and more developed regions (over 90%).
For the period 2014–20, EUR 351 billion will be invested in the EU’s regions with most being directed to the less developed regions.» Basert på plottet fra foregående oppgave diskuter (veldig!) kort om tiltaket ser ut til å virke.

Basert på plottet over ser det ut som den regionale ulikheten i GDP synker, i tråd med målsetningen til EU.
Trenden er vedvarende over tid, men det er vanskelig å si at overføringene har hatt en kausal effekt.

### Oppgave 20

```{r}
eu_data_nested <- gini_n3_nest |>
  left_join(gini_n2_nest, by = c("nc", "nc_name")) |>
  left_join(gini_n1_nest, by = c("nc", "nc_name")) |>
  left_join(gini_NUTSc_nest, by = c("nc", "nc_name"))
```

## Plots som viser utviklingen

```{r}
gini_nc |>
  ggplot(
    mapping = aes(
      x = as.numeric(time),
      y = gini_nc,
      group = nc,
      colour = nc_name
    )
  ) +
  geom_line(lwd = 0.75) +
  theme(legend.position = "bottom") +
  ggtitle("Utviklingen i Gini-koeffisienten på nasjonsnivå (29 land)") +
  labs(
    x = "time",
    y = "gini_nc",
    colour = NULL
  )
```
