---
title: "Arbeidskrav_4_DataScience"
papersize: a4
format: 
  html: default
  typst: default
  pdf: default
editor: visual
---

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(readxl)
library(restatapi)
library(DescTools)
library(ggrepel)
library(flextable)
library(modelr)
library(plm)
library(broom)
library(sandwich)
```

```{r}
if(Sys.info()["sysname"] == "Windows") Sys.setlocale("LC_ALL", "Norwegian")
```

Oppgaven handler om å hente regionale tall fra Eurostat direkte inn i R ved hjelp av et API.
Daten brukes til å analysere økonomiske forskjeller mellom regioner i Europa.
Arbeidskravet vil dermed ha:

-   Henter data på laveste regionale nivå (NUTS3)

-   Summerer (aggregerer) dataene oppover til NUTS2, NUTS1 og til slutt landnivå

-   Ser på BNP, befolkning og BNP per innbygger

-   Beregning av Gini-koeffisient for å måle ulikhet mellom regioner

    -   Innen hvert land (Mellom regioner)

    -   Samlet for EU + utvalgte søkerland

-   Dataene dekker perioden 2000 - 2023

-   Bruker tidyverse og list-columns for å organisere dataene ryddig, slik at hver rad kan inneholde egne datasett (nested tibbles).

## Toc. eurostat

Her velger vi å søke i tox_txt etter tabeller med BNP (GDP) på NUTS3-nivå ved hjelp av str_detect().

```{r}
# Her henter vi innholdsfortegnelsen fra Eurostat og legger det inn i en dataframe vi kaller "toc_txt"
toc_txt <- get_eurostat_toc(mode = "txt")

```

## GDP NUTS 3

Her henter vi inholdsfortegnelsen fra Eurostat.
Vi gjør dette ved å hente innholdsfortegnelsen i rent tekst format, der vi gir navnet toc_txt.
Siden vi ikke vet helt om det brukes store eller småe bokstaver her, så bruker vi regex for å matche begge deler.
Ved å bruke filter() velger vi tabeller som inneholder både "gdp" og "NUTS3", og med å bruke slect() ta vi kun med kollonene title og code.

Tabellen vises med flextable(), som gjør at resultatene kan lett leses.
For å sikre at begge ordene finnes i tittelen, bruker ci en AND-betingelse (&) mellom to str_detect() uttrykk.

```{r}
gdp_tabs <- toc_txt |>
# Regex AND external to regex
 filter(
 str_detect(
 string = title,
 # For å matche både små og store bokstaver
 pattern = '[Gg][Dd][Pp]'
 # AND vha. &
 ) &
 str_detect(
 string = title,
 # For å matche både små og store bokstaver og
 # space eller ikke før 3
 pattern = '[Nn][Uu][Tt][Ss]\\s*3'
 )
 ) |>
 select(title, code)
```

```{r}
gdp_tabs |>
 select(title, code) |>
 flextable() |>
 width(1, width = 3.5) |>
 width(2, width = 1.5)
```

Her bruker tabellen med koden nama_10r_3gdp, som inneholder BNP (GDP) på NUTS3-nivå.
For å se hvilken variabler og verder som finnes i datasettet, henter ci "Data Structure Definition" (DSD).
Denne informasjonen brukes til å sette riktige filters i spørringen mot Eurostat.
Det er spesielt viktig å bruke nuts_leve = "3" for å fikre at vi henter data på NUTS3-nivå, siden dette ikke er åpenbart dokumentert.

Vi Laster dermed ned «Data Structure Definition (DSD)» for tabellen med kode nama_10r_3gdp.

```{r}
# description nama_10r_3gdp
dsd_gdp <- get_eurostat_dsd("nama_10r_3gdp")
```

```{r}
dsd_gdp |>
 filter(concept %in% c('freq', 'unit')) |>
 flextable() |>
 width(j = 1, width = 1) |>
 width(j = 2, width = 2) |>
 width(j = 3, width = 2)
```

```{r}
dsd_gdp |>
 filter(concept %in% c('geo')) |>
 head(n = 10) |>
 flextable() |>
 width(j = 1, width = 1) |>
 width(j = 2, width = 2) |>
 width(j = 3, width = 2)
```

Utfra kodene i dsd_gdpkan vi da formulere følgende spørring mot Eurostat:

```{r}
#| eval: true
#| cache: true
# Gross domestic product (GDP) at current market prices by NUTS 3 regions
# id: nama_10r_3gdp
# Vi velger å hente samtlige soner for så å filtrere ut de få vi ikke trenger
gdp <- get_eurostat_data(
 id = "nama_10r_3gdp",
 filters = list(
 # neste linje viser hvordan vi kunne ha hentet ut data
 # for spesifiserte land
 # geo = c("AT", "DE", "DK", "FR"),
 nuts_level = "3",
 unit = "MIO_PPS_EU27_2020"
 ),
 exact_match = FALSE,
 date_filter = 2000:2023,
 stringsAsFactors = FALSE
 ) |>
 mutate(
 gdp_n3 = 1000000 * values
 ) |> 
  select(-c(unit, values)) |>
 # Vil bare ha NUTS 3 nivå (5 karakterer). Vil aggregere selv til NUTS2,
 # NUTS1 og NUTSc
 filter(str_length(geo) == 5) |> 
 as_tibble()
```

```{r}
dim(gdp)
```

```{r}
# ag: ikke skriv 30000 observasjoner ut til skjerm
# jeg har lagt til head()
gdp |> head(n = 10)
```

```{r}
#| paged.print: false
# ag: et alternativ er å bruke `#| paged.print: false`
gdp
```


Her har vi konvertert gdp til euro fra milioner euro.
Vi vil og gi navnet gdp.
Vi velger og å benytte MI0_PPS_EU27_2020 som mål på BNP.

Vi har et lite problem for sonen IE053.
Her mangler vi gdp data for årene 2015, 2016 og 2017.
Dette vil gi oss problemer senere hvis vi ikke fikser det.

```{r}
#| paged.print: false
gdp |>
 filter(geo == "IE053")

```

Vi legger derfor disse til gdp som NA verdier.
Disse vil vi så erstatte med interpolerte verdier senere.

```{r}
ie_data <- tibble(
 geo = c("IE053", "IE053", "IE053"),
 time = c("2015", "2016", "2017"),
 gdp_n3 = c(NA, NA, NA)
)
```

```{r}
gdp <- rbind(gdp, ie_data)
```

```{r}
gdp <- gdp |>
 arrange(geo, time) |>
 mutate(
 gdp_n3 = zoo::na.approx(gdp_n3)
 )
```

```{r}
gdp |>
 filter(geo == "IE053") |>
 print(n = 25)
```

## Population demo_r_pjanaggr3

#### Oppgave 1

1\.
Søk i toc_txt for tabeller med population og NUTS 3.
Pass på at dere dekker både population og Population og ulike skrivemåter for NUTS 3.
Vi vil bruke befolkningstabellen som har teksten: «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».

```{r}
pop_tab <- toc_txt |>
  filter(
    str_detect(title, regex("population", ignore_case = TRUE)) &
    str_detect(title, regex("NUTS\\s*3", ignore_case = TRUE))
  )
```

#### Oppgave 2

i\.
Finn koden for tabellen med forklarende tekst «Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 regions».

```{r}
pop_tab |>
  filter(
    str_detect(title, regex("population", ignore_case = TRUE)) &
    str_detect(title, regex("NUTS\\s*3", ignore_case = TRUE))
  )

```

```{r}
pop_tab |>
  filter(
    str_detect(
      title,
      fixed("Average annual population to calculate regional GDP data (thousand persons) by NUTS 3 region")
    )
  ) |>
  select(code)
```

ii. Last ned Data Structure Definition (DSD) for denne tabellen.

```{r}
# Så laster vi ned DSD for tabellen vi fant over.
dsd_pop <- get_eurostat_dsd("nama_10r_3popgdp")
```

iii. Bruk opplysningene i DSD for å formulere en spørring mot Eurostat og last ned dataene. Gi dataene lastet ned navnet pop. Vi er bare interessert i totalbefolkning og ignorerer derfor både kjønn og alder. Vi ønsker data for årene 2000-2023.

<!-- -->

iv. Bruk filter(str_length(geo) == 5) for å begrense datasettet til NUTS3 regioner.
    Vi vil gjøre vår egen aggregering.

v.  Hent data for samtlige land, dvs.
    vi trenger ikke sette noe filter for geo.
    Husk å konverter til tibble vha.
    as_tibble().

```{r}
#| eval: true
#| cache: true
pop <- get_eurostat_data(
 id = "nama_10r_3popgdp",
 filters = list(
 nuts_level = "3",
 unit = "THS"
 ),
 exact_match = FALSE,
 date_filter = 2000:2023,
 stringsAsFactors = FALSE
 ) |>
 mutate(
 pop_n3 = values * 1000
 ) |> 
  select(-c(unit, values)) |>
 filter(str_length(geo) == 5) |> 
 as_tibble()
```

```{r}
dim(pop)
```

#### Oppgave 3

Gjør en left_join() av de to tabellene.
La gdp være venstre tabell (Viktig!).
Gi resultatet navnet gdp_pop.

```{r}
gdp_pop <- left_join(
  gdp,
  pop,
  by = c("geo", "time")
)
```

```{r}
dim(gdp_pop)
```

```{r}
#| paged.print: false
# ag: igjen paged.print: false gjør susen
gdp_pop
```


Gjør følgende tilpasning av gdp_pop og legger resultatet i variabelen eu_data.

```{r}
eu_data <- gdp_pop %>%
 # Trenger ikke ZZ sonene som er en slag oppsamlingssone
 # for ikke fordelte verdier
 filter(!str_sub(geo, 3, 4) == "ZZ") |>
 # Drop the EFTA countries Switzerland and Norway
 filter(!str_sub(geo, 1, 2) %in% c("CH", "NO")) |>
 # Drop the EU countries Netherlands and Portugal
 filter(!str_sub(geo, 1, 2) %in% c("NL", "PT")) |>
 # Drop candidate country Monte Negro because of data
 filter(!str_sub(geo, 1, 2) %in% c("ME")) |>
 # Drop a region of France in the Indian Ocean (Outre Mer); Mayotte
 # because of missing data
 filter(!geo == "FRY50") |>
 # note that a few countries will have missing data for
 # some years at the start of the period
 filter(time > 1999 & time < 2023)
```

Regn ut gdp per capita og kaller variabelen gdp_pc_n3.

```{r}
eu_data <- eu_data |>
  mutate(
    gdp_pc_n3 = gdp_n3 / pop_n3
  )
```

```{r}
dim(eu_data)
```

```{r}
miss_eu <- eu_data %>% 
  filter(!complete.cases(.))
dim(miss_eu)
```

#### Oppgave 4

Endre navnet på variabelen geo til n3 og lag variablene n2 (NUTS2), n1 (NUTS1) og nc (for «Country») fra variabelen n3.
Funksjonen str_sub() fra stringr pakken kan her være hendig å bruke.

```{r}
eu_data <- eu_data |>
  rename(
    n3 = geo
  ) |>
  mutate(
    n2 = str_sub(n3, 1, 4), #Adding column for NUTS2
    n1 = str_sub(n3, 1, 3), #NUTS1
    nc = str_sub(n3, 1, 2) # And finally country.s
  )
```

#### Oppgave 5

Undersøk om vi har noen NUTS 3 soner med pop_n3 lik 0.
Hvis det er noen så endre disse til NA.

```{r}
# Sjekker om det finnes soner uten befolkning. Så synes ikke, og livet går videre. 
eu_data |>
  filter(pop_n3 == 0)
```

#### Oppgave 6

Sjekker hvor mange NUTS3 soner vi har i hvert land.

```{r}
# ag: dere må sette max_row, ellers får dere bare med de 10 første
# tabellen blir litt lang. Se under for forslag til kode som lager en mer
# kompakt tabell
eu_data |>
  distinct(nc, n3)|>
  count(nc, name ="antall_nuts3")|>
  as_flextable(
    show_coltype = FALSE,
    max_row = 30
  ) |> 
  line_spacing(space = 0.3)
```

```{r}
#| message: false
#| paged.print: false
eu_data |>
  distinct(nc, n3)|>
  count(nc, name ="antall_nuts3") |>
  add_row()  |> 
  add_row()  |> 
  add_row() %>%
  {
    list(
      p1 = slice(., 1:8),
      p2 = slice(., 9:16),
      p3 = slice(., 17:24),
      p4 = slice(., 25:32)
    )
  } |> 
  bind_cols() |> 
  flextable() |> 
  set_table_properties(
    opts_pdf = list(
      arraystretch = 0.8
      )
    ) |> 
  set_header_labels(
    nc...1 = "Land\nkode",
    antall_nuts3...2 = "Antall\nnuts3",
    nc...3 = "Land\nkode",
    antall_nuts3...4 = "Antall\nnuts3",
    nc...5 = "Land\nkode",
    antall_nuts3...6 = "Antall\nnuts3",
    nc...7 = "Land\nkode",
    antall_nuts3...8 = "Antall\nnuts3"
  ) |> 
  line_spacing(space = 0.5) |> 
  align(align = "left", part = "all") |> 
  autofit()
```

#### Oppgave 7

Sjekk summary gdp_pc_n3.
Hva er største og minste verdi?
Har vi noen NA?

```{r}
  summary(eu_data$gdp_pc_n3)
```

Minsteverdi er 2 214, mens høyeste er 180 416.
Ingen NA.

#### Oppgave 8

Bruker case_when() for å legge til variabelen nc_name før vi går videre.
Østerrike for AT, Belgia for BE etc..

```{r}
eu_data <- eu_data |>
  mutate(
    nc_name = case_when(
      nc == "AL" ~ "Albania",
      nc == "AT" ~ "Østerrike",
      nc == "BE" ~ "Belgia",
      nc == "BG" ~ "Bulgaria",
      nc == "CY" ~ "Kypros",
      nc == "CZ" ~ "Tjekkia",
      nc == "DE" ~ "Tyskland",
      nc == "DK" ~ "Danmark",
      nc == "EE" ~ "Estland",
      nc == "EL" ~ "Hellas",
      nc == "ES" ~ "Spania",
      nc == "FI" ~ "Finland",
      nc == "FR" ~ "Frankrike",
      nc == "HR" ~ "Kroatia",
      nc == "HU" ~ "Ungarn",
      nc == "IE" ~ "Irland",
      nc == "IT" ~ "Italia",
      nc == "LT" ~ "Litauen",
      nc == "LU" ~ "Luxemburg",
      nc == "LV" ~ "Latvia",
      nc == "MK" ~ "Nord-Makedonia",
      nc == "MT" ~ "Malta",
      nc == "PL" ~ "Polen",
      nc == "RO" ~ "Romania",
      nc == "RS" ~ "Serbia",
      nc == "SE" ~ "Sverige",
      nc == "SI" ~ "Slovania",
      nc == "SK" ~ "Slovakia",
      nc == "TR" ~ "Tyrkia",
      TRUE ~ NA_character_
    )
  )
```


## Beregning av Gini

#### Oppgave 9

Bruk koden nedenfor til å beregne Gini-koeffisienter på NUTS2 nivå.
Finn også antall NUTS3 regioner som finnes i hver NUTS2 region.
Gi denne variabelen navnet num_reg_n2.
Vi beregner også populasjon og gdp på NUTS2 nivå.
Resultatet legger dere i en tibble kalt gini_n2.

```{r}
gini_n2 <- eu_data |>
 group_by(n2, time, n1, nc, nc_name) |>
 summarise(
 gini_n2 = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
 pop_n2 = sum(pop_n3),
 gdp_n2 = sum(gdp_n3),
 gdp_pc_n2 = gdp_n2 / pop_n2,
 num_reg_n2 = n(),
 .groups = "drop"
 )|>
  as_tibble()
```

```{r}
head(gini_n2, 10)
```

```{r}
#| paged.print: false
# ag: 10 første rekker gini_n2
gini_n2
# ag: legger en inn `options(paged.print = FALSE)` så får en
# dete automatisk
```


```{r}
summary(gini_n2)
```

#### Oppgave 10

Sjekk obs.
med Gini mindre enn 0.001.
Er det noe som kjennetegner disse regionene?

For å løse denne gikk vi inn i R-objektet og filtrerte etter utregnet Gini.
Når vi filtrerte etter Gini mellom 0 og 0,001 fikk vi 4 observasjoner:

```{r}
gini_n2 %>%
  filter(gini_n2 < 0.001)
```

De er spredt geografisk, i tid og har forskjellig GDP.
Det de derimot har til felles, er at alle inneholder 2 NUTS3-regioner.
At de har få regioner å regne ulikhet fra påvirker resultatet.

#### Oppgave 11

Beregn Gini-koeffisienter på NUTS1 nivå (ut fra gdp_pc_n3og pop_n3).
Legg resultatet i gini_n1.
Et alternativ her ville vært å beregnet Gini fra gdp_pc_n2 og pop_n2 i NUTS1 regionene.
Vi får imidlertid større spredning og trolig også et bedre mål på likhet/ulikhet ved å beregne Gini utfra gdp_pc_n3og pop_n3.

```{r}
#Trur denne er rett?
# ag: Ser bra ut. Stemmer med mine resultater ;-)
gini_n1 <- eu_data |>
  group_by(n1, time, nc, nc_name) |>
  summarise(
    gini_n1 = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
    pop_n1 = sum(pop_n3, na.rm = TRUE),
    gdp_n1 = sum(gdp_n3, na.rm = TRUE),
    gdp_pc_n1 = gdp_n1 / pop_n1,
    num_reg_n1 = n_distinct(n3),
    .groups = "drop"
  ) |>
  as_tibble()
```

Vår summary:

```{r}

gini_n1 |>
 select(gini_n1, num_reg_n1, gdp_n1, pop_n1, gdp_pc_n1) |>
 summary() |>
 print(width = 76)
```

Ser lik ut som "fasit".
Great success!
High five.

#### Oppgave 12

Beregn Gini-koeffisienter (ut fra variasjon i verdiskapning på NUTS3 nivå) på nasjonsnivå.
Legg resultatet i gini_nc.

```{r}
gini_nc <- eu_data |>
  group_by(nc, nc_name, time) |>
  summarise(
    gini_nc = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
    pop_nc = sum(pop_n3, na.rm = TRUE),
    gdp_nc = sum(gdp_n3, na.rm = TRUE),
    gdp_pc_nc = gdp_nc / pop_nc,
    num_reg_nc = n_distinct(n3),
    .groups = "drop"
  ) |>
  as_tibble()
```

```{r}
summary(gini_nc)
```

Denne ser også ut som løsningsforslaget.

## Nestete Datastrukturer

#### Oppgave 13

```{r}
gini_n3_nest <- eu_data |>
 group_by(nc_name, nc) |>
 nest(.key = "NUTS3_data") |>
 ungroup()

```

#### Oppgave 14

Nest dataene på NUTS2 nivå.
Legg resultatet gini_NUTS2_nest.
Bruk .key = "NUTS2_data".

```{r}
gini_n2_nest <- gini_n2 |>
  group_by(nc_name, nc)|>
 nest(.key = "NUTS2_data")
```

#### Oppgave 15

«Nest» dataene på NUTS1 nivå.
Legg resultatet gini_NUTS1_nest.

```{r}
gini_n1_nest <- gini_n1 |>
 group_by(nc_name, nc) |>
 nest(.key = "NUTS1_data") |>
 ungroup()
```

#### Oppgave 16

«Nest» dataene på nasjonsnivå.
Legg resultatet i gini_NUTSc_nest.

```{r}
gini_NUTSc_nest <- gini_nc |>
 group_by(nc_name, nc) |>
 nest(.key = "NUTSc_data") |>
 ungroup()
```

#### Oppgave 17

```{r}
gini_NUTSeu_nest <- eu_data |>
 group_by(time) |>
 summarise(
 gini_eu = DescTools::Gini(gdp_pc_n3, weights = pop_n3, na.rm = TRUE),
 num_reg_eu = n(),
 .groups = "drop")
```

#### Oppgave 18

Vis utviklingen i Gini-koeffisienten for NUTS3 regioner i EU vha.
et linjeplot.

```{r}
gini_NUTSeu_nest |>
  ggplot(aes(x = as.numeric(time), y = gini_eu)) +
  geom_line() +
  labs(
    x = "Year",
    y = "gini_eu"
  )
```

#### Oppgave 19

«The EU’s Structural Funds and Cohesion Fund direct funding to NUTS level 2 regions based on their GDP (PPS) per capita in comparison to the EU average: less developed regions (less than 75%), transition regions (between 75% and 90% and more developed regions (over 90%).
For the period 2014–20, EUR 351 billion will be invested in the EU’s regions with most being directed to the less developed regions.» Basert på plottet fra foregående oppgave diskuter (veldig!) kort om tiltaket ser ut til å virke.

Basert på plottet over ser det ut som den regionale ulikheten i GDP synker, i tråd med målsetningen til EU.
Trenden er vedvarende over tid, men det er vanskelig å si at overføringene har hatt en kausal effekt.

#### Oppgave 20

```{r}
eu_data_nested <- gini_n3_nest |>
  left_join(gini_n2_nest, by = c("nc", "nc_name")) |>
  left_join(gini_n1_nest, by = c("nc", "nc_name")) |>
  left_join(gini_NUTSc_nest, by = c("nc", "nc_name"))
```

## Plots som viser utviklingen

```{r}
gini_nc |>
  ggplot(
    mapping = aes(
      x = as.numeric(time),
      y = gini_nc,
      group = nc,
      colour = nc_name
    )
  ) +
  geom_line(lwd = 0.75) +
  # ag: her vil jeg foreslå legend til høure
  #theme(legend.position = "bottom") +
  ggtitle("Utviklingen i Gini-koeffisienten på nasjonsnivå (29 land)") +
  labs(
    x = "time",
    y = "gini_nc",
    colour = NULL
  )
```

#### Oppgave 22

Lag en sortert tabell for Gini i år 2022 som gjør det litt lettere å se hvilken linje som hører til hvilket land

```{r}
gini_2022 <- gini_nc |>
  filter(time == 2022) |>
  arrange(desc(gini_nc)) |>
  select(nc_name, gini_nc)

# Skriv ut tabellen
gini_2022 |>
  flextable() |>
  set_header_labels(
    nc_name = "Land",
    gini_nc = "Gini-koeffisient"
  ) |>
  autofit()

```

```{r}
#| message: false
# ag: mer kompakt variant
gini_2022 |> 
  mutate(gini_nc = round(gini_nc, 4)) %>%
  {
    list(
      p1 = slice(., 1:14,),
      p2 = slice(., 15:28,)
    )
  } |> 
  bind_cols() |>
  flextable() |> 
  # ag: for pdf (latex)
  set_table_properties(
    opts_pdf = list(
      arraystretch = 1.2
    )
  ) |> 
  line_spacing(space = 0.7) |> 
  set_header_labels(
    nc_name...1 = "Land",
    gini_nc...2 = "Gini\nkoeff.",
    nc_name...3 = "Land",
    gini_nc...4 = "Gini\nkoeff."
  ) |> 
  align(align = "left", part = "all") |> 
  line_spacing(space = 0.3) |> 
  autofit()
```



#### Oppgave 23

Del landene i to grupper, dem som har lavere Gini i 2022 enn første året (dvs. utgjevning over tid mellom regionene) og dem som har høyere Gini i 2022 enn første året (dvs. større forskjeller mellom regionene).
Vis utviklingen i de to gruppene vha.
linjeplot.

```{r}
gini_compare <- gini_nc |>
  group_by(nc, nc_name) |>
  summarise(
    gini_first = gini_nc[time == min(time)],
    gini_2022  = gini_nc[time == 2022],
    .groups = "drop"
  ) |>
  mutate(
    gruppe = if_else(
      gini_2022 < gini_first,
      "Lavere Gini i 2022",
      "Høyere Gini i 2022"
    )
  )
```

```{r}
gini_nc_grouped <- gini_nc |>
  left_join(
    gini_compare |> select(nc, gruppe),
    by = "nc"
  )
```

```{r}
gini_nc_grouped |>
  filter(gruppe == "Lavere Gini i 2022") |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gini_nc,
      group = nc,
      colour = nc_name
    )
  ) +
  geom_line(lwd = 0.75) +
  theme_minimal() +
  theme(legend.position = "right") +
  labs(
    x = "Year",
    y = "gini_nc",
    colour = "nc_name"
  ) +
  ggtitle("Land med lavere regional ulikhet i 2022 enn første år vi har data for")

```

```{r}
gini_nc_grouped |>
  filter(gruppe == "Høyere Gini i 2022") |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gini_nc,
      group = nc,
      colour = nc_name
    )
  ) +
  geom_line(lwd = 0.75) +
  theme_minimal() +
  theme(legend.position = "right") +
  labs(
    x = "Year",
    y = "gini_nc",
    colour = "nc_name"
  ) +
  ggtitle("Land med høyere regional ulikhet i 2022 enn første år vi har data for")
```

#### Oppgave 24

Vis vha.
et linjeplot utviklingen i gini-koeffisient for NUTS2 regionene i Irland.

```{r}
gini_n2 |>
  filter(nc == "IE") |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gini_n2,
      group = n2,
      colour = n2
    )
  ) +
  geom_line(lwd = 0.75) +
  theme_minimal() +
  labs(
    x = "Year",
    y = "gini_n2",
    colour = "n2"
  ) +
  ggtitle("Utviklingen i gini-koeffisienten for NUTS2-regionene i Irland")
```

## Hvordan er verdiskapningen fordelt mellom regionene i ulike land?

### Spania

Spania hadde i år 2022 en Gini-koeffisient lik 0,134 som skulle tilsi en nokså jevn fordeling av økonomisk aktivitet mellom regionene.

#### Oppgave 25

#### Lag et line-plot som viser utviklingen i Gini-koeffisientene for NUTS2 regionene i Spania.

```{r}
gini_n2 |>
  filter(nc == "ES") |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gini_n2,
      group = n2,
      colour = n2
    )
  ) +
  geom_line(lwd = 0.75) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  labs(
    x = "Year",
    y = "gini_n2",
    colour = "n2"
  ) +
  ggtitle("Utviklingen i Gini-koeffisienten for NUTS2-regionene i Spania")

```

#### Oppgave 26

Lag et line-plot som viser utviklingen i Gini-koeffisientene for NUTS1 regionene i Spania.

```{r}
gini_n1 |>
  filter(nc == "ES") |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gini_n1,
      group = n1,
      colour = n1
    )
  ) +
  geom_line(lwd = 0.75) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  labs(
    x = "Year",
    y = "gini_n1",
    colour = "n1"
  ) +
  ggtitle("Utviklingen i Gini-koeffisienten for NUTS1-regionene i Spania")
```

Er det noe som karakteriserer de NUTS1 regionene som har hatt økt utgjevning?

```{r}
utjevning_es_n1 <- gini_n1 |>
  filter(nc == "ES") |>
  group_by(n1) |>
  summarise(
    gini_first = gini_n1[time == min(time)],
    gini_2022  = gini_n1[time == 2022],
    endring = gini_2022 - gini_first,
    .groups = "drop"
  ) |>
  arrange(endring)

utjevning_es_n1
```

NUTS1-regionene som har hatt økt utjevning kjennetegnes ved at forskjellene i verdiskapning mellom deres underliggende NUTS3-regioner har blitt mindre over tid.
Dette indikerer en mer balansert økonomisk utvikling innen regionene, der veksten i større grad har kommet flere delregioner til gode, og ikke bare vært i fokus i et spesifikt område.

## Tyskland

Tyskland hadde i år 2020 en Gini-koeffisient lik 0,20 som skulle tilsi en nokså jevn fordeling av økonomisk aktivitet mellom regionene.
Tyskland ligger likevel relativt høyt blandt landene vi har i vårt utvalg.
Dette skulle indikere større spredning mellom regionene i Tyskland.

#### Oppgave 27

Lag et line-plot som viser utviklingen i Gini-koeffisient for NUTS2 regionene i Tyskland.
Dropp gjerne farger.
Det er så mange regioner at de er vanskelig å skille.

```{r}
gini_n2 |>
  filter(nc == "DE") |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gini_n2,
      group = n2
    )
  ) +
  geom_line(color = "black", linewidth = 0.6, alpha = 0.8) +
  theme_minimal() +
  labs(
    x = "Year",
    y = "gini_n2"
  ) +
  ggtitle("Utviklingen i Gini-koeffisienten for NUTS2-regionene i Tyskland")
```

Figuren viser at Gini-koeffisientene for NUTS2-regionene i Tyskland er fra rundt 0,03 til over 0,45.
Dette indikerer store forskjeller i intern regional ulikhet.
Regioner med lav Gini fremstår som ensartede når det gjelder verdiskapning mellom NUTS3-områder, mens regioner med høy Gini er preget av betydelige interne forskjeller.
De største regionale ulikhetene finnes i hovedsak i og rundt de store økonomiske sentrene og storbyregionene.
Dette et hvertfall i de vestlige og sørlige delene av landet, der de sterke kjerneområder eksisterer med mindre utviklede regioner.

#### Oppgave 28

Er det samme er tilfelle når vi ser på de større regionene i Tyskland (NUTS1).

```{r}
gini_n1 |>
  filter(nc == "DE") |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gini_n1,
      group = n1,
      colour = n1
    )
  ) +
  geom_line(linewidth = 0.9) +
  theme_minimal() +
  theme(
    legend.position = "bottom"
  ) +
  labs(
    x = "Year",
    y = "gini_n1",
    colour = "NUTS1"
  ) +
  ggtitle("Utviklingen i Gini-koeffisienten for NUTS1-regionene i Tyskland")
```

```{r}
eu_data_nested |>
 unnest(NUTS1_data) |>
 filter(nc_name == "Tyskland") |>
 filter(time == "2022") |>
 select(n1, gini_n1, num_reg_n1) |>
 arrange(desc(gini_n1)) |>
 flextable() |>
 line_spacing(space = 0.3) |>
 colformat_double(j = 2, digits = 4)
```

## Frankrike

Frankrike hadde i år 2022 en Gini-koeffisient lik 0,206 som også skulle tilsi en nokså jevn fordeling av økonomisk aktivitet mellom regionene.
Frankrike ligger imidlertid høyt blant landene vi har i vårt utvalg.

#### Oppgave 29

Vis utviklingen i Gini-koeffisient for NUTS1 regionene i Frankrike i et line-plot.
Plottet vil se slik ut.

```{r}
gini_n1 |>
  filter(nc == "FR") |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gini_n1,
      group = n1,
      colour = n1
    )
  ) +
  geom_line(linewidth = 0.9) +
  theme_minimal() +
  theme(
    legend.position = "bottom"
  ) +
  labs(
    x = "Year",
    y = "gini_n1",
    colour = "NUTS1"
  ) +
  ggtitle("Utviklingen i Gini-koeffisienten for NUTS1-regionene i Frankrike")
```

#### Oppgave 30

Lag en tabell som viser de 6 NUTS1 sonene i Frankrike som hadde høyest Gini-koeffisient i 2022.
Hvilken sone har suverent høyest Gini-koeffisient og hvor ligger denne i landet?

```{r}
gini_n1 |>
  filter(nc == "FR", time == 2022) |>
  arrange(desc(gini_n1)) |>
  slice_head(n = 6) |>
  select(n1, gini_n1) |>
  flextable() |>
  set_header_labels(
    n1 = "NUTS1-sone",
    gini_n1 = "Gini-koeffisient (2022)"
  ) |>
  autofit()
```

NUTS1-sonen i Frankrike som har høyest Gini-koeffisient i 2022 er FR1.
Denne regionen ligger rundt Paris, og skiller seg ut med større interne regionale forskjeller enn resten av landet.
Den høye Gini-koeffisienten reflekterer store forskjeller i verdiskapning mellom NUTS3-regionene i og rundt hovedstadsområdet, sammenlignet med mer homogene regioner ellers i Frankrike.

#### Oppgave 31

Vi ser at for Frankrike er det en region som har klart større forskjeller mht.
vekst (verdiskapning) enn de andre.
Sjekk NUTS3 regionenen i denne regionen nærmere vha.
linjeplot og lag en tabell som viser gdp_pc_n3 for de seks sonene.

```{r}
# Finn NUTS1-regionen i Frankrike med høyest Gini i 2022
top_fr_n1 <- gini_n1 |>
  filter(nc == "FR", time == 2022) |>
  arrange(desc(gini_n1)) |>
  slice(1) |>
  pull(n1)

# Plot gdp per capita (NUTS3) over tid for NUTS3-sonene i denne NUTS1-regionen
eu_data |>
  filter(nc == "FR", n1 == top_fr_n1) |>
  ggplot(
    aes(
      x = as.numeric(time),
      y = gdp_pc_n3,
      group = n3,
      colour = n3
    )
  ) +
  geom_line(lwd = 0.75) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  labs(
    x = "Year",
    y = "gdp_pc_n3",
    colour = "NUTS3"
  ) +
  ggtitle(paste0("GDP per capita (NUTS3) i ", top_fr_n1, " (Frankrike)"))
```

```{r}
eu_data |>
  filter(nc == "FR", n1 == top_fr_n1, time == 2022) |>
  arrange(desc(gdp_pc_n3)) |>
  slice_head(n = 6) |>
  select(n3, gdp_pc_n3) |>
  flextable() |>
  set_header_labels(
    n3 = "NUTS3-sone",
    gdp_pc_n3 = "GDP per capita (2022)"
  ) |>
  autofit()
```

Resultatene viser at den høye Gini-koeffisienten i FR1 i stor grad skyldes svært store forskjeller mellom NUTS3-regionene i området rundt Paris.
To regioner har et ekstremt høyt BNP per innbygger, mens de øvrige regionene ligger på et langt lavere nivå.
Dette betyr at en stor del av verdiskapningen er konsentrert i noen få områder, mens resten av regionen har en mer moderat utvikling.
Den sterke konsentrasjonen rundt hovedstadsområdet forklarer hvorfor FR1 skiller seg tydelig ut med høy regional ulikhet sammenlignet med andre deler av Frankrike.

#### Oppgave 32

Kan vi utfra foregåenede plot og tabell si noe om årsaken til at FR1 har så høy Ginikoeffisient?

Kort svar, Ja.
Ut fra plottet og tabellen våras kan vi si noe om årsaken til den høye Gini-koeffisienten i FR1.
Verdiskapningen er svært ulikt fordelt mellom NUTS3-regionene i området.
Noen få regioner rundt Paris har ekstremt høyt BNP per innbygger, mens resten ligger betydelig lavere.
Denne sterke konsentrasjonen av økonomisk aktivitet i enkelte områder gjør at forskjellene innad i regionen blir store, og forklarer hvorfor FR1 har så høy Gini-koeffisient.

# Enkle modeller

## «Data Science» modeller

#### Oppgave 33

Lag datasett for endringer i gdp_per_capita og gini_nuts2

```{r}
n3_data <- eu_data_nested |>
 unnest(NUTS3_data) |>
 select(nc_name, n2, n3, time, gdp_pc_n3)
```

```{r}
n2_data <- eu_data_nested |>
 unnest(NUTS2_data) |>
 select(nc_name, n2, time, gini_n2)
```

```{r}
NUTS2_diff <- n3_data |>
 left_join(n2_data, by = join_by(nc_name, n2, time)) |>
 mutate(
 diff_gdp_per_capita = c(NA, 100 * diff(gdp_pc_n3)),
 diff_gini_nuts2 = c(NA, 100 * diff(gini_n2))
 ) %>%
 filter(complete.cases(.)) |>
 group_by(nc_name, n2) |>
 nest(.key = "NUTS2_diff")
```

Vi har totalt 256 NUTS2 regioner men bare:

```{r}
unnest(NUTS2_diff, NUTS2_diff) |>
 ungroup() |>
 filter(!is.nan(gini_n2)) |>
 select(n2) |>
 distinct() |>
 nrow()
```

av disse har vi kunnet beregne Gini-koeffisient for.
Vi har altså 38 NUTS2 soner som bare inneholder én NUTS3 sone.

#### Oppgave 34

Bruk modellen diff_gini_nuts2 \~ diff_gdp_per_capita på hver av de 256 (218) NUTS2 regionene vha.
en anonym funksjon som «mappes» (vha. map()) på «list-column» NUTS2_diff.
Legg resultatet i en variabel modell.

```{r}
NUTS2_diff <- NUTS2_diff |>
  mutate(
    modell = map(
      .x = NUTS2_diff,
      .f = function(a_df) lm(diff_gini_nuts2 ~ diff_gdp_per_capita, data = a_df)
    )
  )
```

#### Oppgave 35

Hent ut koeffisientene fra de 256 (218) modellene og legg resultatet i variabelen mod_coeff.
Gjør dette ved å «mappe» funksjonen coeff() på list_column modell.
(Hint: Husk at hvis vi ønsker en dataframe så må \_df varianten av mapbrukes. Nå er map_df() blitt «superseded» i Tidyverse, dvs.
at den ikke lengre blir utviklet og brukerne er oppfordret til å bruke map() som returnerer en liste.
Her betyr det av vi bytter ut map_df(.x =, .f =) med bind_rows(map(.x =, .f =)).

```{r}
mod_coeff <- bind_rows(
  map(
    .x = NUTS2_diff$modell,
    .f = coef
  )
)
```

#### Oppgave 36

Brukk glance() funksjonen fra broom pakken og «map» denne på modell variabelen for å generere «model summary».
Legg resultatet i en variabel mod_sum.

```{r}
NUTS2_diff <- NUTS2_diff |>
 group_by(nc_name, n2) |>
 mutate(
 mod_sum = bind_rows(
 map(
 .x = modell,
 .f = glance
 )
 )
 )
```

#### Oppgave 37

Hvilken NUTS1 sone har høyest R² for vår modell og hvilken sone har lavest.

```{r}
#Lag mod_sum og mod_coeff som list-columns (én per NUTS2-region)
NUTS2_diff2 <- NUTS2_diff |>
  ungroup() |>
  mutate(
    mod_sum   = map(modell, glance),
    mod_coeff = map(modell, coef)
  )

#Gjør mod_sum "flat" så r.squared blir en vanlig kolonne
mods_flat <- NUTS2_diff2 |>
  unnest(mod_sum) |>
  filter(is.finite(r.squared))

#Høyest og lavest R^2
hoyest_R2 <- mods_flat |>
  arrange(desc(r.squared)) |>
  slice(1) |>
  select(nc_name, n2, r.squared)

lavest_R2 <- mods_flat |>
  arrange(r.squared) |>
  slice(1) |>
  select(nc_name, n2, r.squared)

hoyest_R2
lavest_R2
```

```{r}
mods_flat |>
  arrange(desc(r.squared)) |>
  slice_head(n = 3) |>
  select(nc_name, n2, NUTS2_diff, modell, mod_coeff, r.squared)|>
  unnest(mod_coeff)

```

#### Oppgave 38

Hvilken NUTS1 sone har høyest koeffisient for diff_gdp_per_capita?

```{r}
mods_flat |>
  unnest(mod_coeff)|>
  arrange(desc(mod_coeff)) |>
  select(nc_name, n2, NUTS2_diff, modell, mod_coeff, r.squared)
  
```

NUTS2-regionen med høyest koeffisient: AL02 i Albania.

#### Oppgave 39

Hvor mange av de 256 (218) koeffisientene er signifikante på 5% nivå?

```{r}
# Hent ut koeffisient-estimat og p-verdi fra alle modellene
coef_tidy <- NUTS2_diff2 |>
  select(nc_name, n2, modell) |>
  mutate(
    tidy_coef = map(modell, tidy)
  ) |>
  unnest(tidy_coef) |>
  filter(term == "diff_gdp_per_capita") |>
  filter(is.finite(p.value))
```

```{r}
coef_tidy |>
  summarise(
    totalt_antall = n(),
    signifikante_5pct = sum(p.value < 0.05),
    andel_signifikante = mean(p.value < 0.05)
  )
```

Av de totale 218 regioner var 162 modeller statistisk signifikante på 5 % nivå.
Det betyr at for rundt 3 av 4 regioner er sammenhengen mellom endringer i BNP per innbygger og endringer i regional ulikhet ikke tilfeldig, men målbar i dataene.

#### Oppgave 40

Bruk ggplot til å lage et «density plot» av variabelen diff_gdp_per_capita.
Legg inn en vertikal linje for gjennomsnitt diff_gdp_per_capita.
(Hint! Husk argumentet na.rm = TRUE.).
Resultatet skal bli som i plottet under.

```{r}
coef_tidy |>
  ggplot(aes(x = estimate)) +
  geom_density(na.rm = TRUE) +
  geom_vline(
    xintercept = mean(coef_tidy$estimate, na.rm = TRUE),
    linetype = "dashed"
  ) +
  theme_minimal() +
  labs(
    x = "diff_gdp_per_capita",
    y = "Density",
    title = "Tetthetsplot av diff_gdp_per_capita"
  )
```

#### Oppgave 41

Hvor mange av de 256 (218) regrersjonskoeffisientene for diff_gdp_per_capita er positive?

```{r}
coef_tidy |>
  summarise(
    totalt_antall = n(),
    antall_positive = sum(estimate > 0),
    andel_positive = mean(estimate > 0)
  )
```

Svaret visar et flertall av NUTS2-regionene på om lag 61 %, som er sammenhengen mellom endringer i BNP per innbygger og endringer i regional ulikhet positiv.

#### Oppgave 42

```{r}
coef_tidy |>
  summarise(
    mean_coef   = mean(estimate),
    median_coef = median(estimate)
  )
```

#### Oppgave 43

Utfør en enkel t-test for å teste om diff_gdp_per_capita er signifikant større enn 0.
Er diff_gdp_per_capita signifikant større enn 0?

```{r}
t.test(
  coef_tidy$estimate,
  mu = 0,
  alternative = "greater"
)
```

## Panel modell

#### Oppgave 44

Bruk funksjonen plm() fra pakken plm til å utføre en panel-regresjon på dataene.
For argumentet index kan dere bruke index = c("n3", "time").
Bruk samme enkle modell som ovenfor dvs.
diff_gini_nuts2 \~ diff_gdp_per_capita.
Putt resultatet av regresjonen i et objekt p_mod.

```{r}
# Her skjærer det seg.Lag-funksjonen fungerer ikke, av en eller 
# annen grunn. Har prøvd å debugge både vha. Claude og ChatGPT i 
# timesvis, til ingen nytte. Dette lager følgefeil for resten 
# av panelestimeringen.
panel_n3 <- n3_data %>%
  left_join(n2_data, by = c("nc_name", "n2", "time")) %>%
  mutate(time = as.integer(time)) %>%
  arrange(nc_name, n3, time) %>%  # Sort BEFORE grouping
  group_by(nc_name, n3) %>%
  mutate(
    gdp_pc_lag  = dplyr::lag(gdp_pc_n3, 1),
    gini_n2_lag = dplyr::lag(gini_n2, 1)
  ) %>%
  mutate(
    # ag: ingenting kan slå ekte intelligens ;-)
    # dere har havnet borti stats::lag() som virker
    # anderledes (langt mindre intuitivt) enn dplyr::lag()
    diff_gdp_per_capita = 100 * (gdp_pc_n3 - dplyr::lag(gdp_pc_n3)),
    diff_gini_nuts2     = 100 * (gini_n2 - dplyr::lag(gini_n2))
  ) %>%
  ungroup() %>%
  filter(!is.na(diff_gdp_per_capita), !is.na(diff_gini_nuts2)) %>%
  mutate(time = as.numeric(time))

p_mod <- plm(
  diff_gini_nuts2 ~ diff_gdp_per_capita,
  data  = panel_n3,
  index = c("n3", "time"),
  model = "pooling"
)

summary(p_mod)
```

Hvorfor så komplisert? Har dere ikke sett REMA reklamen «Det enkle er ofte det beste»?

```{r}
p_mod <- NUTS2_diff |> 
  select(n2, nc_name, NUTS2_diff) |> 
  unnest(NUTS2_diff)|> 
  plm(
    formula = 'diff_gini_nuts2 ~ diff_gdp_per_capita',
    data = _,
    index = c("n3", "time"),
    model = "within"
  )
```



#### Oppgave 45

Vis summary() for p_mod og tolk resultatet.

```{r}
summary(p_mod)
```

#### Oppgave 46

En alternativ måte å finne summary() for p_mod er gjengitt i chunk-en nedenfor.
**Forklar hva som blir gjort her og sammenlign med resultatet av en ordinær summary().**

```{r}
summary(
  p_mod,
  vcov = function(x) plm::vcovHC(x, method = "white2")
)
```

Vi har fått et robust SE estimat.

